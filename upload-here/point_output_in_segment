
module point(
    input clk, reset, hit, enemy1, enemy2, enemy3, boss, // point uut(.clk(clk), .reset(reset), .hit(맞은거 확인하는 모듈?), .enemy1(부하1 모듈), .enemy2(부하2 모듈), .enemy3(부하3 모듈)); 이렇게 설정하면 될듯?
    output reg [7:0] digit, seg_data
    );

        reg [26:0] point;
    
        always @(posedge clk or negedge reset) begin
            if (!reset)
                point <= 0;
            else if (hit) begin
                if (enemy1)
                    point <= point + 100; // 부하1 점수 설정 + 다음에 원하는 점수 넣으면됨.
                else if (enemy2)
                    point <= point + 200; // 부하2 점수 설정
                else if (enemy3)
                    point <= point + 150; // 부하3 점수 설정
                else if (boss)
                    point <= point + 10000; // 보스 점수 설정s
            end
        end
        
        wire clk_1000hz;
        clock_divider #(49999) div1(.clk(clk), .reset(reset), .clk_out(clk_1000hz));
        
        reg [2:0] sel; 
    
        always @(posedge clk_1000hz, negedge reset) begin
            if (!reset) begin
                sel <= 0;
                digit <= 8'b0000_0001;
            end else begin
                sel <= sel + 1;
                digit <= {digit[0], digit[7:1]}; 
            end
        end
        
        integer temp;
        reg [3:0] digit_value[7:0]; 
    
        always @(*) begin
            temp = point;
            digit_value[0] = temp % 10; temp = temp / 10;
            digit_value[1] = temp % 10; temp = temp / 10;
            digit_value[2] = temp % 10; temp = temp / 10;
            digit_value[3] = temp % 10; temp = temp / 10;
            digit_value[4] = temp % 10; temp = temp / 10;
            digit_value[5] = temp % 10; temp = temp / 10;
            digit_value[6] = temp % 10; temp = temp / 10;
            digit_value[7] = temp % 10;
        end
                  
        always @(*) begin
        case (digit_value[sel])
            4'd0: seg_data = 8'b1111_1100; // 0
            4'd1: seg_data = 8'b0110_0000; // 1
            4'd2: seg_data = 8'b1101_1010; // 2
            4'd3: seg_data = 8'b1111_0010; // 3
            4'd4: seg_data = 8'b0110_0110; // 4
            4'd5: seg_data = 8'b1011_0110; // 5
            4'd6: seg_data = 8'b1011_1110; // 6
            4'd7: seg_data = 8'b1110_0000; // 7
            4'd8: seg_data = 8'b1111_1110; // 8
            4'd9: seg_data = 8'b1111_0110; // 9
            default: seg_data = 8'b0000_0000;
        endcase
        end
        
        
        
endmodule
     
module clock_divider #(
        parameter div = 49999999   
        )(
        input clk_in, reset,            
        output reg clk_out         
        );
        
        reg [25:0] q;              
    
        always @(posedge clk_in or negedge reset) begin
            if (!reset) begin
                q <= 0;
                clk_out <= 0;
            end else begin
                if (q == div) begin
                    clk_out <= ~clk_out;
                    q <= 0;
                end else begin
                    q <= q + 1;
                end
            end
        end 

endmodule
